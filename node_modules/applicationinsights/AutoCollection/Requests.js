///<reference path="..\Declarations\node\node.d.ts" />
var http = require("http");
var url = require("url");
var ContractsModule = require("../Library/Contracts");
var Logging = require("../Library/Logging");
var Util = require("../Library/Util");
var AutoCollectRequests = (function () {
    function AutoCollectRequests(client) {
        if (!!AutoCollectRequests.INSTANCE) {
            throw new Error("Request tracking should be configured from the applicationInsights object");
        }
        AutoCollectRequests.INSTANCE = this;
        this._client = client;
    }
    AutoCollectRequests.prototype.enable = function (isEnabled) {
        this._isEnabled = isEnabled;
        if (this._isEnabled && !this._isInitialized) {
            this._initialize();
        }
    };
    AutoCollectRequests.prototype.isInitialized = function () {
        return this._isInitialized;
    };
    AutoCollectRequests.prototype._initialize = function () {
        var _this = this;
        this._isInitialized = true;
        var originalServer = http.createServer;
        http.createServer = function (onRequest) {
            // todo: get a pointer to the server so the IP address can be read from server.address
            return originalServer(function (request, response) {
                if (_this._isEnabled) {
                    AutoCollectRequests.trackRequest(_this._client, request, response);
                }
                if (typeof onRequest === "function") {
                    onRequest(request, response);
                }
            });
        };
    };
    /**
     * Tracks a request
     */
    AutoCollectRequests.trackRequest = function (client, request, response, properties) {
        if (!request || !response || !client) {
            Logging.info("AutoCollectRequests.trackRequest was called with invalid parameters: ", !request, !response, !client);
            return;
        }
        // store data about the request
        var requestDataHelper = new RequestDataHelper(request);
        // async processing of the telemetry
        var processRequest = function (isError) {
            setTimeout(function () {
                requestDataHelper.onResponse(response, properties);
                var data = requestDataHelper.getRequestData();
                var tags = requestDataHelper.getRequestTags(client.context.tags);
                client.track(data, tags);
            }, 0);
        };
        // response listeners
        if (response && response.once) {
            response.once("finish", function () { return processRequest(); });
        }
        // track a failed request if an error is emitted
        if (request && request.on) {
            request.on("error", function (error) {
                if (!properties) {
                    properties = {};
                }
                if (error) {
                    if (typeof error === "string") {
                        properties["erorr"] = error;
                    }
                    else if (typeof error === "object") {
                        for (var key in error) {
                            properties[key] = error[key] && error[key].toString && error[key].toString();
                        }
                    }
                }
                processRequest(true);
            });
        }
    };
    return AutoCollectRequests;
})();
/**
 * Helper class to read data from the requst/response objects and convert them into the telemetry contract
 */
var RequestDataHelper = (function () {
    function RequestDataHelper(request) {
        if (request) {
            this.method = request.method;
            this.url = request.url;
            this.startTime = +new Date();
            this.rawHeaders = request.headers || request.rawHeaders;
            this.socketRemoteAddress = request.socket && request.socket.remoteAddress;
            this.userAgent = request.headers && request.headers["user-agent"];
            if (request.connection) {
                this.connectionRemoteAddress = request.connection.remoteAddress;
                this.legacySocketRemoteAddress = request.connection["socket"] && request.connection["socket"].remoteAddress;
            }
        }
    }
    RequestDataHelper.prototype.onResponse = function (response, errorProperties) {
        this.endTime = +new Date;
        this.statusCode = response.statusCode;
        this.errorProperties = errorProperties;
    };
    RequestDataHelper.prototype.getRequestData = function () {
        var duration = this.endTime - this.startTime;
        var requestData = new ContractsModule.Contracts.RequestData();
        requestData.httpMethod = this.method;
        requestData.id = Util.newGuid();
        requestData.name = this.method + " " + url.parse(this.url).pathname;
        requestData.startTime = (new Date(this.startTime)).toISOString();
        requestData.url = this.url;
        requestData.duration = Util.msToTimeSpan(duration);
        requestData.responseCode = this.statusCode.toString();
        requestData.success = this._isSuccess(this.statusCode);
        requestData.properties = this.errorProperties;
        var data = new ContractsModule.Contracts.Data();
        data.baseType = "Microsoft.ApplicationInsights.RequestData";
        data.baseData = requestData;
        return data;
    };
    RequestDataHelper.prototype.getRequestTags = function (tags) {
        // create a copy of the context for requests since client info will be used here
        var newTags = {};
        for (var key in tags) {
            newTags[key] = tags[key];
        }
        newTags[RequestDataHelper.keys.locationIp] = this._getIp();
        newTags[RequestDataHelper.keys.sessionId] = this._getSessionId();
        newTags[RequestDataHelper.keys.userAgent] = this.userAgent;
        return newTags;
    };
    RequestDataHelper.prototype._isSuccess = function (statusCode) {
        return (statusCode < 400) && !this.errorProperties; // todo: this could probably be improved
    };
    RequestDataHelper.prototype._getIp = function () {
        // regex to match ipv4 without port
        // Note: including the port would cause the payload to be rejected by the data collector
        var ipMatch = /[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/;
        var check = function (str) {
            var results = ipMatch.exec(str);
            if (results) {
                return results[0];
            }
        };
        var ip = check(this.rawHeaders["x-forwarded-for"]) || check(this.rawHeaders["x-client-ip"]) || check(this.rawHeaders["x-real-ip"]) || check(this.connectionRemoteAddress) || check(this.socketRemoteAddress) || check(this.legacySocketRemoteAddress);
        // node v12 returns this if the address is "localhost"
        if (!ip && this.connectionRemoteAddress && this.connectionRemoteAddress.substr && this.connectionRemoteAddress.substr(0, 2) === "::") {
            ip = "127.0.0.1";
        }
        return ip;
    };
    RequestDataHelper.prototype._getSessionId = function () {
        var name = "ai_session";
        var cookie = (this.rawHeaders && this.rawHeaders["cookie"] && typeof this.rawHeaders["cookie"] === 'string' && this.rawHeaders["cookie"]) || "";
        var value = Util.getCookie(name, cookie);
        return value;
    };
    RequestDataHelper.keys = new ContractsModule.Contracts.ContextTagKeys();
    return RequestDataHelper;
})();
module.exports = AutoCollectRequests;
